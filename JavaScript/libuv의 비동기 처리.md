### 1. libuv 핵심구조

libuv는 운영체제마다 다른 비동기 I/O 인터페이스(epoll, kqueue, IOCP)를 추상화하여, Nodejs가 플랫폼에 상관없이 동작하게 해주는 C라이브러리.

### 2. 비동기 처리의 두 가지 전략

#### 커널(OS) 비동기 매커니즘 사용 (Network I/O)

네트워크 소켓 통신이나 파이프 같은 작업은 최신 운영체제 커널이 비동기 처리를 지원한다.

- 동작 방식: libuv는 별도 스레드를 만들지 않고, os에 `이 소켓에 데이터 오면 알려달라`는 감시(Polling)를 요청한다.
- Linux의 epoll, macOS의 kqueue, Windows의 IOCP

과정
```
1. JS 코드에서 네트워크 요청 보냄
2. libuv가 해당 파일 디스크립터를 OS 감시 목록에 등록
3. 이벤트 루프는 다른 작업 계속 수행
4. 데이터 도착하면 OS가 libuv에 알림
5. libuv는 해당 콜백을 메인 스레드의 큐에 넣음
```

#### 스레드 풀 사용 (File I/O, DNS, Crypto)

파일 시스템 작업이나 일부 CPU 집약적인 작업은 운영체제 레벨에서 완벽한 비동기를 지원하지 않거나, 작업 자체가 CPU를 오래 점유한다.<br/> 이를 싱글 스레드에서 처리하면 전체가 멈추게 된다.

- 동작 방식: libuv는 별도로 준비된 스레드 풀에 작업을 보낸다.
- 기본적으로 4개의 스레드를 가진다.
- 적용 대상
  - `fs`모듈
  - DNS 조회 (dns.lookup)
  - 암호화 (crypto)
  - 압축 (zlib)
 
과정
```
1. JS 코드에서 `fs.readFile` 호출
2. libuv에서 이 작업을 즉시 스레드 풀의 남는 스레드(worker)에게 할당
3. 메인 스레드는 해방되어 다음 코드 실행
4. 워커 스레드 작업이 끝나면 libuv에 완료 신호 보냄
5. libuv는 콜백을 메인 스레드 큐에 등록
```

### 3. 전체적인 흐름 (이벤트 루프)

1. Call Stack: JS 코드가 실행된다. 비동기 함수(`setTimeout`, `fetch`) 호출되면 libuv로 넘어간다.
2. libuv
  - 네트워크 작업 -> 커널에 위임
  - 파일/무거운 작업 -> 스레드 풀에 위임
3. Poll Phase: 이벤트 루프는 OS나 스레드 풀로부터 작업이 끝났다는 신호를 받을 떄까지 기다리거나, 이미 완료된 작업의 콜백 실행.
4. Callback Queue: 완료된 작업의 콜백 함수들이 큐에 쌓임.
5. Execution: Call Stack 비어 있으면, 이벤트 루프가 큐에 있는 콜백을 하나씩 Call Stack으로 올려 실행.


Node.js가 싱글 스레드다?

- JS코드는 싱글 스레드에서 돈다.
- 하지만 뒷단의 libuv는 운영체제 멀티플렉싱 기능과 멀티 스레드 풀을 사용하여 무거운 작업을 메인 스레드 밖에서 처리한다.



## 추가 학습 

`dns.lookup`이 스레드 풀로 보내지는 이유는 CPU를 많이 써서가 아니라, 운영체제단에서 동기적으로 동작하여 메인 스레드를 멈추게 하기 때문. 

- 내부적으로 `getaddrinfo` 함수를 호출하는데 이는 동기방식.
- 만약 이벤트 루프에서 직접 실행한다면 DNS 응답이 늦어지는 동안 모든 작업이 멈춰버린다.
